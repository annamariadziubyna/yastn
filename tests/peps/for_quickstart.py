""" Test the expectation values of spin 1/2 fermions with analytical values of fermi sea """
import numpy as np
import yastn
import yastn.tn.fpeps as fpeps


opt = yastn.operators.SpinfulFermions(sym='U1xU1xZ2')
# while initializing basic operators it is possible to specify different backend and device, see ref:`yastn.make_config`


geometry = fpeps.SquareLattice(lattice = 'checkerboard')
# this is for infinite lattice with checkerboard structure; other options incude ...

one = opt.I()
psi = fpeps.product_peps(geometry=geometry, vector = one / 2)
# this prepares as initial state at infinite temperature, which is a product state with

# we will be simulating Hubbard model at a square lattice with parameters
#
# in quaickstart you can explicitly write the Hamiltonian using latex ....
#
mu = 0 # chemical potential
t = 1 # hopping amplitude
U = 0 # Coulomb interaction

#
# Time evolution is generated by infitesimal gates within Suzuki-Trotter decomposition
#
#
dbeta = 0.01
#
# this in latex    exp( - t * dbeta /2  c_1^dag c_2 + c_2^dag c_1)
gate_hopping_u = fpeps.operators.gate_hopping(dbeta, t, opt.I(), opt.c(spin='u'), opt.cp(spin='u'))
gate_hopping_d = fpeps.operators.gate_hopping(dbeta, t, opt.I(), opt.c(spin='d'), opt.cp(spin='d'))
#
# this in latex  exp( - dbeta /2  (n_u n_d) ....)
#
gate_coulomb = fpeps.operators.gate_coulomb(dbeta, mu, mu, U, opt.I(), opt.n(spin='u'), opt.n(spin='d'))
#
#
gates = fpeps.gates_homogeneous(geometry, nn=[gate_hopping_u, gate_hopping_d], local=gate_coulomb)
#

#
#  to obtain a density matrix at inverse temperature beta, the purification is evolved in imaginaty time to beta/2
#
beta = 1
steps = (beta / 2) / dbeta



# env = fpeps.EnvCluster(psi, depth=0)  # this is SVD truncation; remove it


D = 8   # upgrade naming of options
opts = {"D_total": D, "gradual_truncation": False, "initialization": "EAT"}  # truncation options  # should be also bond dimension

# contatins the state psi and information how to calculate metric tensor for truncation; here we use nearest tensor clusters (NTU) environment
env = fpeps.EnvCluster(psi, depth='ntu')
# environment contains a reference to psi

for step in range(steps):
    out = fpeps.evolution_step_(env, gates, opts)
    # psi is updated in place inside the environment

    print(f" time {step * dbeta};  normalized truncation error {np.sqrt(out.truncation_error) / dbeta}")


#
# finally, we calculate expectation values in the final state using CTMRG
#

#
# alternative: env = fpeps.EnvMps(psi, ....)  # this initialize mps environment with trivial or boundary mps-s
#  env.update_()
#

chi = 10,
env = fpeps.EnvCtm(psi, chi=10, init="random or ones")  # initialize CTM environment with identity or random tensors
opts_svd={"D_total" : 5}


def measure_Hubbard_energy(env, t, U, mu):
    pass


for out in env.ctmrg_(max_sweeps=10, iterator_step=1, opts_svd=opts_svd):  # " this can look like dmrg "
    double_occupancy = env.measure_1site(opt.n(spin="u") @ opt.n(spin="d"))  # measure_1site can take operator or dict of operators [site:operator]
    # this return dict[site, value]


    # we can monitor convergence of double_occupancy
    # inspect information on convergence
    env.measure_2site_nn(opt.cp('u'), opt.c('u'))  # this should
    energy = measure_Hubbard_energy(env, t, U, mu)


    # this return dict[(site1, site2), value]

# output the final energy.  and finish here

# to calculate long-range correlations we will be going though EnvMps;
# EnvMps can be initialized from EnvCtm


